<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="noindex, nofollow"><title>Between The Lines: Create Interfaces Using Mesh | linar.dev</title>
<meta name=keywords content><meta name=description content="Divide and conquer User Interface in Unity
I tell you how to create custom UI elements through Mesh creation using Unity and UI Toolkit.
What do we do?
Within the framework of this article, we will analyze the possibilities of generating custom UI elements using the UI Toolkit.
First, we&rsquo;ll take a closer look at creating a triangle based on mash generation, and second - a gradient rhombus!
Chapter 1: Mesh and Triangle!
Within this chapter, let&rsquo;s look at how to make a custom triangle element, as well as tell you in general how this system works."><meta name=author content><link rel=canonical href=http://localhost:1313/posts/btl-create-interfaces-using-mesh/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/btl-create-interfaces-using-mesh/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="linar.dev (Alt + H)">linar.dev</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/archives title=Archive><span>Archive</span></a></li><li><a href=http://localhost:1313/posts/ title=Posts><span>Posts</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Between The Lines: Create Interfaces Using Mesh
<span class=entry-hint title=Draft><svg height="35" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h1><div class=post-meta><span title='2024-10-28 11:12:23 +0700 +07'>October 28, 2024</span>&nbsp;·&nbsp;9 min</div></header><figure class=entry-cover><img loading=eager src=http://localhost:1313/posts/btl-create-interfaces-using-mesh/0.png alt="The alt text"></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#divide-and-conquer-user-interface-in-unity aria-label="Divide and conquer User Interface in Unity">Divide and conquer User Interface in Unity</a><ul><li><a href=#what-do-we-do aria-label="What do we do?">What do we do?</a></li><li><a href=#chapter-1-mesh-and-triangle aria-label="Chapter 1: Mesh and Triangle!">Chapter 1: Mesh and Triangle!</a></li><li><a href=#chapter-2-diamond-and-gradient aria-label="Chapter 2: Diamond and Gradient!">Chapter 2: Diamond and Gradient!</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=divide-and-conquer-user-interface-in-unity>Divide and conquer User Interface in Unity<a hidden class=anchor aria-hidden=true href=#divide-and-conquer-user-interface-in-unity>#</a></h1><p>I tell you how to create custom UI elements through Mesh creation using <strong>Unity</strong> and <strong>UI Toolkit</strong>.</p><h2 id=what-do-we-do>What do we do?<a hidden class=anchor aria-hidden=true href=#what-do-we-do>#</a></h2><p>Within the framework of this article, we will analyze the possibilities of generating custom UI elements using the <strong>UI Toolkit</strong>.</p><p>First, we&rsquo;ll take a closer look at creating a triangle based on mash generation, and second - a gradient rhombus!</p><h2 id=chapter-1-mesh-and-triangle>Chapter 1: Mesh and Triangle!<a hidden class=anchor aria-hidden=true href=#chapter-1-mesh-and-triangle>#</a></h2><p>Within this chapter, let&rsquo;s look at how to make a custom triangle element, as well as tell you in general how this system works.</p><p>So, read the code and comments to it, so you can repeat it at home: ).</p><p><img loading=lazy src=1.png alt=alt></p><p>First, the code will be attached (for the smartest and most intricate) and then there will be a detailed breakdown of most of the points, here we go!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine.UIElements;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> CustomUI
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TriangleElement</span> : VisualElement
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UxmlFactory</span> : UxmlFactory&lt;TriangleElement&gt;
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> TriangleElement()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            generateVisualContent += GenerateVisualContent;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Vertex[] vertices = <span style=color:#66d9ef>new</span> Vertex[<span style=color:#ae81ff>3</span>];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>ushort</span>[] indices = { <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> GenerateVisualContent(MeshGenerationContext mgc)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            vertices[<span style=color:#ae81ff>0</span>].tint = Color.red;
</span></span><span style=display:flex><span>            vertices[<span style=color:#ae81ff>1</span>].tint = Color.red;
</span></span><span style=display:flex><span>            vertices[<span style=color:#ae81ff>2</span>].tint = Color.red;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> leftCorner = <span style=color:#ae81ff>0f</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> rightCorner = contentRect.width;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> top = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> bottom = contentRect.height;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> middleX = contentRect.width / <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            vertices[<span style=color:#ae81ff>0</span>].position = <span style=color:#66d9ef>new</span> Vector3(leftCorner, bottom, Vertex.nearZ);
</span></span><span style=display:flex><span>            vertices[<span style=color:#ae81ff>1</span>].position = <span style=color:#66d9ef>new</span> Vector3(middleX, top, Vertex.nearZ);
</span></span><span style=display:flex><span>            vertices[<span style=color:#ae81ff>2</span>].position = <span style=color:#66d9ef>new</span> Vector3(rightCorner, bottom, Vertex.nearZ);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            MeshWriteData mwd = mgc.Allocate(vertices.Length, indices.Length);
</span></span><span style=display:flex><span>            mwd.SetAllVertices(vertices);
</span></span><span style=display:flex><span>            mwd.SetAllIndices(indices);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is what the code looks like, now let&rsquo;s see what&rsquo;s what!</p><p>Let&rsquo;s start with the base, the declaration of our class - <strong>TriangleElement</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TriangleElement</span> : VisualElement
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    ....
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To create a custom UI element, inheritance of the <strong>VisualElement</strong> class is used. (There are other ways, but I won&rsquo;t go into details right now).</p><p>We will use some methods and data from the parent class, such as <strong>contentRect</strong> and <strong>generateVisualElement</strong>;</p><p>Let&rsquo;s move on to <strong>UxmlFactory</strong> and displaying the element in the hierarchy:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UxmlFactory</span> : UxmlFactory&lt;TriangleElement&gt; { };
</span></span></code></pre></div><p>This is a feature of the <strong>UI Toolkit</strong>, it is necessary for our <strong>TriangleElement</strong> to be added to the general list of UI elements.</p><p>After that, we can easily drag it to the layout window.</p><p><img loading=lazy src=2.png alt=alt></p><p>More details about creating custom elements can be found in the <a href=https://docs.unity3d.com/Packages/com.unity.ui.builder@1.0/manual/uib-structuring-ui-custom-elements.html>documentation</a></p><p>That&rsquo;s taken care of, let&rsquo;s move on:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> TriangleElement()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    generateVisualContent += GenerateVisualContent;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As many of you know, the method we call the constructor is called when our object is created.</p><p>Specifically for us, it subscribes to the <strong>Action</strong> of the parent class (the one mentioned above)</p><p>What Action of the parent class?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#75715e>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;para&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// Called when the VisualElement visual contents need to be (re)generated.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;/para&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> Action&lt;MeshGenerationContext&gt; generateVisualContent { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span></code></pre></div><p>Briefly, it is activated when our <strong>VisualElement</strong> needs to regenerate itself, this usually happens if there were changes in the UI element (change of properties, dimensions) or if the <strong>MarkDirtyRepaint()</strong> method was called</p><p>I will also leave a link to the <a href=https://docs.unity3d.com/ScriptReference/UIElements.VisualElement-generateVisualContent.html>documentation</a></p><p>When we catch this <strong>Action</strong>, we also get <strong>MeshGenerationContext</strong> and thanks to it, we can additionally render geometry on the element.</p><p>The method returns us a value of type - <strong>MeshGenerationContext</strong>, we will understand it later.</p><p>Let&rsquo;s make a small digression and make an introduction to game engines - let&rsquo;s talk about Mesh.</p><p>Mesh is a set of vertices, edges and polygons that define the shape and structure of an object.</p><p>To create a custom element, we create this very mash, but only at the interface level and in 2D space.</p><p>Next we will analyze the minimum data needed to create such an object:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>Vertex[] vertices = <span style=color:#66d9ef>new</span> Vertex[<span style=color:#ae81ff>3</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>ushort</span>[] indices = { <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span> };
</span></span></code></pre></div><p>Meet our valiant elephants, gentlemen — &lsquo;Vertices&rsquo; and &lsquo;Indices&rsquo;; henceforth, we&rsquo;ll refer to them as vertices and indices.</p><p>A Vertex is an internal structure of Unity UI Toolkit, employed in rendering UI elements. The key aspect for us is:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Vertex</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Vector3 position; 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Color32 tint; 
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Under the hood, it utilizes Vector3 for the vertex position and Color32 (32-bit RGBA representation) for the color shade.</p><p>In essence, vertices define their spatial coordinates and color.</p><p>Next up are the indices, responsible for connecting the mesh vertices.</p><p>The majority of game engines and 3D modeling tools employ a triangular mesh approach, where objects are comprised of triangles.</p><p>Similarly, in our case, when we state that the indices array is filled – {0, 1, 2}, we imply that the output will be a triangle formed by these vertices.</p><p>Hence, the minimum description of a shape involves three numbers to outline a single triangle.</p><p><img loading=lazy src=3.png alt=alt></p><p>You can read more about the anatomy of the mesh and its structure <a href=https://docs.unity3d.com/2022.2/Documentation/Manual/AnatomyofaMesh.html>here</a>.</p><p>Moving along in the code, we&rsquo;ve reached the body of our method, which will be invoked upon regenerating our UI element:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>void</span> GenerateVisualContent(MeshGenerationContext mgc)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    vertices[<span style=color:#ae81ff>0</span>].tint = Color.red;
</span></span><span style=display:flex><span>    vertices[<span style=color:#ae81ff>1</span>].tint = Color.red;
</span></span><span style=display:flex><span>    vertices[<span style=color:#ae81ff>2</span>].tint = Color.red;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Keep in mind that our vertices have a &rsquo;tint&rsquo; field (vertex color), and right here is where we&rsquo;ve defined them, setting all to red</p><p>Next, we&rsquo;ll determine their positions (who is where):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> leftCorner = <span style=color:#ae81ff>0f</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> rightCorner = contentRect.width;
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> top = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> bottom = contentRect.height;
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> middleX = contentRect.width / <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>vertices[<span style=color:#ae81ff>0</span>].position = <span style=color:#66d9ef>new</span> Vector3(leftCorner, bottom, Vertex.nearZ);
</span></span><span style=display:flex><span>vertices[<span style=color:#ae81ff>1</span>].position = <span style=color:#66d9ef>new</span> Vector3(middleX, top, Vertex.nearZ);
</span></span><span style=display:flex><span>vertices[<span style=color:#ae81ff>2</span>].position = <span style=color:#66d9ef>new</span> Vector3(rightCorner, bottom, Vertex.nearZ);
</span></span></code></pre></div><p>Let&rsquo;s begin with the fact that the vertex position is described using the Vector3 type (where 3 represents the number of dimensions, i.e., in our case, X, Y, Z).</p><p>To specify positions, we need some theoretical support:</p><p>Any VisualElement has a rendering area called the <a href=https://docs.unity3d.com/ScriptReference/Rect.html>contentRect</a>.
It has properties for height and width.</p><p>I want to draw my triangle always in the center of this area, so that, regardless of the size of the area, my triangle is positioned in the middle.</p><p>That&rsquo;s why I&rsquo;m binding it to the size of the rendering area. If it changes, for example, due to a screen resize, it will trigger the regeneration of the entire UI element. Consequently, this method will be called again, but this time with updated contentRect dimensions.</p><p><img loading=lazy src=4.png alt=alt></p><p>Here, the origin, as you may have noticed, is located in the top-left corner – position { x = 0, y = 0 }.</p><p>The region of our contentRect ends at the values { x = width, y = height }, which is logical overall. The farthest point on the X-axis is equal to the width of the element, and on the Y-axis, it&rsquo;s equal to the height.</p><p>So, what did we end up with in terms of vertices?</p><ul><li>Vertex with index 0 is located at coordinates { x = 0, y = height } (bottom-left corner).</li><li>Vertex with index 1 is located at coordinates { x = width / 2, y = 0 } (top center).</li><li>Vertex with index 2 is located at coordinates { x = width, y = height } (bottom-right corner).</li></ul><p>After preparing the position and color values, it&rsquo;s finally time to render all of this!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>MeshWriteData mwd = mgc.Allocate(vertices.Length, indices.Length);
</span></span><span style=display:flex><span>mwd.SetAllVertices(vertices);
</span></span><span style=display:flex><span>mwd.SetAllIndices(indices);
</span></span></code></pre></div><p>Here, in short, we are saying that we want to create a mesh with a certain number of vertices and a specific number of indices.</p><p>Then, through the SetAllVertices() method, we define our vertices, and through SetAllIndices(), we assign our indices.</p><p>And voilà! We&rsquo;ve got ourselves a triangle:</p><p><a href=/posts/btl-create-interfaces-using-mesh/5.mov></a></p><h2 id=chapter-2-diamond-and-gradient>Chapter 2: Diamond and Gradient!<a hidden class=anchor aria-hidden=true href=#chapter-2-diamond-and-gradient>#</a></h2><p>Now, after the simple triangle, let&rsquo;s move on to something more interesting – a diamond.</p><p>We&rsquo;ll proceed as follows. Below is the code, and we&rsquo;ll provide an overview of only the important parts that have changed.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine.UIElements;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> CustomUI
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RombElement</span> : VisualElement
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UxmlFactory</span> : UxmlFactory&lt;RombElement&gt; { }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> RombElement()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            generateVisualContent += GenerateVisualContent;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Vertex[] vertices = <span style=color:#66d9ef>new</span> Vertex[<span style=color:#ae81ff>4</span>];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>ushort</span>[] indices = { <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> GenerateVisualContent(MeshGenerationContext mgc)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            vertices[<span style=color:#ae81ff>0</span>].tint = <span style=color:#66d9ef>new</span> Color32(<span style=color:#ae81ff>255</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>255</span>);
</span></span><span style=display:flex><span>            vertices[<span style=color:#ae81ff>1</span>].tint = <span style=color:#66d9ef>new</span> Color32(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>255</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>255</span>);
</span></span><span style=display:flex><span>            vertices[<span style=color:#ae81ff>2</span>].tint = <span style=color:#66d9ef>new</span> Color32(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>255</span>, <span style=color:#ae81ff>255</span>);
</span></span><span style=display:flex><span>            vertices[<span style=color:#ae81ff>3</span>].tint = <span style=color:#66d9ef>new</span> Color32(<span style=color:#ae81ff>17</span>, <span style=color:#ae81ff>55</span>, <span style=color:#ae81ff>55</span>, <span style=color:#ae81ff>255</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> top = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> left = <span style=color:#ae81ff>0f</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> middleX = contentRect.width / <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> middleY = contentRect.height / <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> right = contentRect.width;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> bottom = contentRect.height;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            vertices[<span style=color:#ae81ff>0</span>].position = <span style=color:#66d9ef>new</span> Vector3(left, middleY, Vertex.nearZ);
</span></span><span style=display:flex><span>            vertices[<span style=color:#ae81ff>1</span>].position = <span style=color:#66d9ef>new</span> Vector3(middleX, top, Vertex.nearZ);
</span></span><span style=display:flex><span>            vertices[<span style=color:#ae81ff>2</span>].position = <span style=color:#66d9ef>new</span> Vector3(right, middleY, Vertex.nearZ);
</span></span><span style=display:flex><span>            vertices[<span style=color:#ae81ff>3</span>].position = <span style=color:#66d9ef>new</span> Vector3(middleX, bottom, Vertex.nearZ);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            MeshWriteData mwd = mgc.Allocate(vertices.Length, indices.Length);
</span></span><span style=display:flex><span>            mwd.SetAllVertices(vertices);
</span></span><span style=display:flex><span>            mwd.SetAllIndices(indices);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As you can see, our vertices and indices have changed.</p><p>Now, we have 4 vertices, which is precisely what we need to create a rectangle, as we recall from geometry lessons.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>Vertex[] vertices = <span style=color:#66d9ef>new</span> Vertex[<span style=color:#ae81ff>4</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>ushort</span>[] indices = { <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>0</span>};
</span></span></code></pre></div><p>Now, let&rsquo;s delve into the indices!</p><p>Let&rsquo;s break down the indices into triplets, resulting in {0, 1, 2} and {2, 3, 0}.</p><p>Now, let&rsquo;s illustrate our vertices and indices.</p><p><img loading=lazy src=6.png alt="For the first triplet, we use a dashed red line, and for the second one – blue."></p><p>When it comes to the vertex positions, there&rsquo;s nothing new or complex there; it&rsquo;s as straightforward as it gets.</p><p>But what&rsquo;s interesting is the gradient and vertex colors!</p><p>For the triangle, all vertices had the value of Color.red. We can express this in the RGBA representation, and it would look like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> redColor = <span style=color:#66d9ef>new</span> Color32(<span style=color:#ae81ff>255</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>255</span>);
</span></span></code></pre></div><p>Yes, we can pass any color values and shades that can be described using RGBA.</p><p>But how do we create a gradient then? To answer that, let&rsquo;s address the question – what is this gradient of yours?</p><p>A gradient in computer graphics is a type of fill that, based on specified color parameters at key points, calculates intermediate colors for other points.</p><p>There are various types of gradients: radial, angular, reflected.</p><p>We&rsquo;ll be creating a linear gradient, and it looks like this</p><p><img loading=lazy src=6.png alt></p><p>Now, let&rsquo;s get back to our business and break down our vertices and colors:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>vertices[<span style=color:#ae81ff>0</span>].tint = <span style=color:#66d9ef>new</span> Color32(<span style=color:#ae81ff>255</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>255</span>); <span style=color:#75715e>// Red</span>
</span></span><span style=display:flex><span>vertices[<span style=color:#ae81ff>1</span>].tint = <span style=color:#66d9ef>new</span> Color32(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>255</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>255</span>); <span style=color:#75715e>// Green </span>
</span></span><span style=display:flex><span>vertices[<span style=color:#ae81ff>2</span>].tint = <span style=color:#66d9ef>new</span> Color32(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>255</span>, <span style=color:#ae81ff>255</span>); <span style=color:#75715e>// Blue </span>
</span></span><span style=display:flex><span>vertices[<span style=color:#ae81ff>3</span>].tint = <span style=color:#66d9ef>new</span> Color32(<span style=color:#ae81ff>17</span>, <span style=color:#ae81ff>55</span>, <span style=color:#ae81ff>55</span>, <span style=color:#ae81ff>255</span>); <span style=color:#75715e>// Dark-green </span>
</span></span></code></pre></div><p>Here&rsquo;s how the UI element will look like:
<img loading=lazy src=7.png alt></p><p>Each vertex is colored in its own shade, and as we transition to another vertex, color blending occurs, resulting in the desired gradient.</p><p>However, there&rsquo;s a small nuance – a difference in colors between UI Builder and Runtime. I&rsquo;ll demonstrate that now:</p><p><img loading=lazy src=8.png alt=alt></p><p>This issue arises from the fact that different color spaces are used in Runtime and UI Builder.</p><p>This becomes especially noticeable during color blending, as in our gradient.</p><p>I found confirmations of this on Unity forums:</p><ul><li><a href=https://forum.unity.com/threads/colors-do-not-match-ui-builder-uss-variables.1420835/>Colors do not match ui builder</a></li><li><a href=https://forum.unity.com/threads/ui-builder-doesnt-support-linear-color-space-and-ui-toolkit-too.1235737/>UI Builder does not support linear color space</a></li><li><a href=https://forum.unity.com/threads/uielements-runtime-with-different-color-spaces.823395/>UIElements Runtime with different color spaces</a></li></ul><p>What can be done, or will our gradient have this nuance?</p><p>By default, after creating a project, the <a href=https://docs.unity3d.com/Manual/LinearRendering-LinearOrGammaWorkflow.html>Linear color space</a> is used.</p><p><img loading=lazy src=9.png alt=alt></p><p>If you switch to Gamma, everything will fall into place, and it will come to life with new colors:</p><p><img loading=lazy src=10.png alt=alt></p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>linar.dev</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>